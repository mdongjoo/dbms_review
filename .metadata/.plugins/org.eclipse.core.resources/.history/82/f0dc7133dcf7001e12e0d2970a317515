SELECT * FROM TBL_PRODUCT ;
SELECT * FROM TBL_ORDER;

CREATE TABLE TBL_ORDER(
	ORDER_ID NUMBER CONSTRAINT PK_ORDER PRIMARY KEY,
	PRODUCT_NUMBER NUMBER,
	ORDER_DATE DATE,
	FOREIGN KEY(PRODUCT_NUMBER) REFERENCES TBL_PRODUCT(PRODUCT_NUMBER)
);

-- 데이터 저장(DML - INSERT INTO)
INSERT INTO TBL_PRODUCT
VALUES(1, '아이패드 에어', 790000);

INSERT INTO TBL_PRODUCT
VALUES(2, '애플워치', 900000); -- 오류 상품번호가 pk라서 중복을 허용하지 않음 2로 변경

INSERT INTO TBL_PRODUCT
VALUES(3, '갤럭시워치', 500000); -- 오류 상품번호가 PK라서 NULL을 허용하지 않음 3으로 변경


--[실습] TBL_ANIMAL
-- 동물 테이블 생성
--고유번호(NUMBER) , 종류 , 나이 , 먹이 컬럼 추가 
--1)테이블 조회 

--2)제약 조건 추가 PK
--3)컬럼추가 성별 
--4)컬럼 이름 수정(고유번호) NUMBER -> NUM 
--5)컬럼 삭제 (먹이)
--6)제약 조건 삭제 (PK)
--7)컬럼 수정(종류 컬럼을 다른 자료형으로 )

--동물 테이블 삭제후 생성
DROP TABLE TBL_ANIMAL ; --동물 테이블 삭제
CREATE TABLE TBL_ANIMAL(--고유번호, 종류 ,나이, 먹이
	ANIMAL_NUMBER NUMBER,
	ANIMAL_KIND VARCHAR2(1000),
	ANIMAL_AGE NUMBER,
	ANIMAL_FEED VARCHAR2(1000)
);
--동물 테이블 조회
SELECT * FROM TBL_ANIMAL;

--제약 조건 추가 PK 
ALTER TABLE TBL_ANIMAL ADD CONSTRAINT PK_ANIMAL PRIMARY KEY(ANIMAL_NUM);

--컬럼 추가 성별 
ALTER TABLE TBL_ANIMAL  ADD(ANIMAL_GENDER CHAR(4));
--컬럼 이름 수정(고유번호) NUMBER -> NUM 
ALTER TABLE TBL_ANIMAL RENAME COLUMN ANIMAL_NUMBER TO ANIMAL_NUM;
--컬럼 삭제 (먹이)
ALTER TABLE TBL_ANIMAL DROP COLUMN ANIMAL_FEED ;
--제약 조건 삭제 (PK)
ALTER TABLE TBL_ANIMAL DROP CONSTRAINT PK_ANIMAL ;
--컬럼 수정(종류 컬럼을 다른 자료형으로 )
ALTER TABLE TBL_ANIMAL MODIFY (ANIMAL_KIND VARCHAR2(500));

--동물 테이블 삭제 
DROP TABLE TBL_ANIMAL ;

--학교 테이블
CREATE TABLE TBL_SCHOOL(
	SCHOOL_NUMBER NUMBER,
	SCHOOL_NAME VARCHAR2(1000),
	CONSTRAINT PK_SCHOOL PRIMARY KEY(SCHOOL_NUMBER)
);

SELECT * FROM TBL_SCHOOL ;

DROP TABLE TBL_STUDENT ;
--학생 테이블
CREATE TABLE TBL_STUDENT (
	STUDENT_NUMBER NUMBER,
	STUDENT_NAME VARCHAR2(1000),
	STUDENT_AGE NUMBER,
	SCHOOL_NUMBER NUMBER,
	CONSTRAINT PK_STUDENT PRIMARY KEY(STUDENT_NUMBER),
	CONSTRAINT FK_STUDENT FOREIGN KEY(SCHOOL_NUMBER)REFERENCES TBL_SCHOOL(SCHOOL_NUMBER)
);
SELECT * FROM TBL_STUDENT ;

-- FK를 가진 테이블에 값을 넣기 -> PK를 가진 테이블의 값을 먼저 추가해야한다 
INSERT INTO TBL_SCHOOL 
VALUES(1,'JAVA 고등학교');

INSERT INTO TBL_SCHOOL 
VALUES(2,'DBMS 고등학교');

INSERT INTO TBL_SCHOOL 
VALUES(3,'WEB 고등학교');

SELECT * FROM TBL_SCHOOL ;


--학생테이블 값 추가
INSERT INTO TBL_STUDENT 
VALUES(1,'김철수',17,1);

INSERT INTO TBL_STUDENT 
VALUES(2,'신짱구',17,1);

INSERT INTO TBL_STUDENT 
VALUES(3,'유리',19,2);

INSERT INTO TBL_STUDENT 
VALUES(4,'맹구',17,3);

INSERT INTO TBL_STUDENT 
VALUES(5,'영희',19,2);

--철수와 짱구는 어느 학교에 소속되어있는가 1
--유리와 영희는 어느 학교에 소속되어있는가 2

--UK 와 PK 차이 
-- PK :  고유한 값을 가지며 데이터 행을 구별하는 구분점으로 사용된다. NULL 허용하지 않는다
-- UK :  고유한 값 , NULL을 허용한다 

DROP TABLE TBL_STUDENT ;

--학생테이블 생성
--학생 번호 , 학생 아이디, 학생 이름 , 전공 , 성별 
CREATE TABLE TBL_STUDENT(
	STUDENT_NUMBER NUMBER CONSTRAINT PK_STUDENT PRIMARY KEY,
	STUDENT_ID VARCHAR2(1000) CONSTRAINT UK_STUDENT UNIQUE,--UK 설정시 KEY붙이지 않음
	STUDENT_NAME VARCHAR2(1000),
	STUDENT_MAJOR VARCHAR2(1000),
--	STUDENT_GENDER CHAR(1),--W,M 만 저장할 것이므로 고정크기 1로 설정
	STUDENT_GENDER CHAR(1) DEFAULT 'W' NOT NULL CONSTRAINT BAN_CHAR CHECK(STUDENT_GENDER = 'W' OR STUDENT_GENDER = 'M')
	--DEFAULT 'W'는 데이터가 들어오지 않으면 무조건'W'가 기본으로 들어가게 해준다 
	-- 디폴트 값을 W로 설정했으니 NULL 값을 강제로 넣는것을 막는 것이 좋을 것이다 => NOT NULL 
	-- 이 컬럼에 M, W만 들어오게 하는 제약조건을 걸어준 CHECK 제약조건 
	--저장 되려는 값이 'M' 또는 'W'인지 검사해야한다 
);
SELECT * FROM TBL_STUDENT ;


DROP TABLE TBL_STUDENT ;

INSERT INTO TBL_STUDENT
VALUES(1,'AA','김철수','컴공' ,'M');

INSERT INTO TBL_STUDENT
VALUES(2,'BB','신짱구','컴공' ,'M');

INSERT INTO TBL_STUDENT
VALUES(3,NULL,'맹구','컴공' ,'M');

INSERT INTO TBL_STUDENT(STUDENT_NUMBER, STUDENT_ID,STUDENT_NAME,STUDENT_MAJOR)
VALUES(4,'DD','유리','컴공');

-- 조합키 : PK 2개의 컬럼으로 조합해서 설정하는 것 
CREATE TABLE TBL_FLOWER(
	FLOWER_NAME VARCHAR2(1000),
	FLOWER_COLOR VARCHAR2(1000),
	FLOWER_PRICE NUMBER,
	CONSTRAINT PK_FLOWER PRIMARY KEY(FLOWER_NAME, FLOWER_COLOR)
);

SELECT * FROM TBL_FLOWER ;

INSERT INTO TBL_FLOWER 
VALUES('해바라기','빨강',5000);

INSERT INTO TBL_FLOWER 
VALUES('해바라기','노랑',10000);

INSERT INTO TBL_FLOWER 
VALUES('튤립','빨강',5000);

INSERT INTO TBL_FLOWER 
VALUES('튤립','노랑',5000);

INSERT INTO TBL_FLOWER 
VALUES('해바라기','노랑',5000); -- 오류 , 조합키 2개의 컬럼의 값이 모두 일치함 


--[실습]
--	TBL_PHONE
--	----------------------
--	PHONE_SERIAL_NUMBER VARCHAR2(1000) PK
--	PHONE_COLOR VARCHAR2(1000)
--	PHONE_SIZE NUMBER
--	PHONE_PRICE NUMBER
--	PHONE_PRODUCTION_DATE DATE
--	PHONE_SALE NUMBER
--
--	TBL_CASE
--	-------------------------
--	CASE_SERIAL_NUMBER VARCHAR2(1000) PK
--	CASE_COLOR VARCHAR2(1000)
--	CASE_PRICE NUMBER
--	PHONE_SERIAL_NUMBER VARCHAR2(1000) FK

CREATE TABLE TBL_PHONE(
	PHONE_SERIAL_NUMBER VARCHAR2(1000),
	PHONE_COLOR VARCHAR2(1000),
	PHONE_SIZE NUMBER,
	PHONE_PRICE NUMBER,
	PHONE_PRODUCTION_DATE DATE,
	PHONE_SALE NUMBER,
	CONSTRAINT PK_PHONE PRIMARY KEY(PHONE_SERIAL_NUMBER)
);
SELECT * FROM TBL_PHONE ;

CREATE TABLE TBL_CASE(
	CASE_SERIAL_NUMBER VARCHAR2(1000),
	CASE_COLOR VARCHAR2(1000),
	CASE_PRICE NUMBER,
	PHONE_SERIAL_NUMBER VARCHAR2(1000),
	CONSTRAINT PK_CASE PRIMARY KEY(CASE_SERIAL_NUMBER),
	CONSTRAINT FK_CASE FOREIGN KEY(PHONE_SERIAL_NUMBER) REFERENCES TBL_PHONE(PHONE_SERIAL_NUMBER)   
);
SELECT * FROM TBL_CASE ;--CREATE하면 바로 SELECT 



--[실습]
DROP TABLE TBL_MEMBER;
CREATE TABLE TBL_MEMBER(
MEMBER_SERIAL_NUMBER VARCHAR2(1000),
	MEMBER_NAME VARCHAR2(1000),
	MEMBER_AGE NUMBER,
	MEMBER_PHONE VARCHAR2(1000) NOT NULL CONSTRAINT UK_MEMBER UNIQUE,
	MEMBER_ADDRESS VARCHAR2(1000) NOT NULL,
	CONSTRAINT PK_MEMBER PRIMARY KEY(MEMBER_SERIAL_NUMBER)
);
SELECT * FROM TBL_MEMBER ;

CREATE TABLE TBL_BOOK(
	BOOK_SERIAL_NUMBER VARCHAR2(1000),
	BOOK_NAME VARCHAR2(1000) NOT NULL, 
	BOOK_GENRE VARCHAR2(1000) DEFAULT '인문학' NOT NULL CONSTRAINT CHECK_GENRE CHECK(BOOK_GENRE = '인문학' OR BOOK_GENRE = '추리' OR BOOK_GENRE = 'IT'),
	MEMBER_SERIAL_NUMBER VARCHAR2(1000),
	CONSTRAINT PK_BOOK PRIMARY KEY(BOOK_SERIAL_NUMBER),
	CONSTRAINT FK_BOOK FOREIGN KEY(MEMBER_SERIAL_NUMBER) REFERENCES TBL_MEMBER(MEMBER_SERIAL_NUMBER)
);
SELECT * FROM TBL_BOOK;
DROP TABLE TBL_BOOK ;

--[DML]
SELECT * FROM TBL_PHONE;
SELECT * FROM TBL_CASE;

-- 자식 테이블은 부모 테이블의 값을 참조하기 때문에 항상 부모 테이블에 데이터가 먼저 들어가야한다 !
--PHONE CASE 테이블에서도 PHONE 테이블이 부모이므로 먼저 데이터를 추가해야한다
INSERT INTO TBL_PHONE
VALUES('S24-001','WHITE',1,100,'2024-01-01',0);
--DATE타입의 컬럼에 문자타입의 값을 'YYYY-MM-DD'형태로 넣으면 자동으로 DATE 타입으로 변화되어 들어간다 
INSERT INTO TBL_PHONE
VALUES('S24-002','BLACK',1,100,SYSDATE -10 ,10);
--현재 날짜 기준 10일전 
INSERT INTO TBL_PHONE
VALUES('S24-003','BLACK',1,120,TO_DATE('2024-02-14') ,20);
--TO_DATE()함수를 이용해서 문자열을 직접 DATE 타입으로 변경가능함 
 
--자식 테이블에 값을 추가 
INSERT INTO TBL_CASE
VALUES('A','WHITE',5,'S24-001');

INSERT INTO TBL_CASE
VALUES('B','WHITE',5,'S24-002');

INSERT INTO TBL_CASE
VALUES('C','BLACK',5,'S24-003');

--부모 테이블의 값을 수정
UPDATE TBL_PHONE 
SET PHONE_SERIAL_NUMBER = 'S24-004'
WHERE PHONE_SERIAL_NUMBER = 'S24-002';

--부모의 값을 변경시 자식에서 참조중인 값을 변경하려고 한다면 오류가 발생한다 
--자식 테이블에서 먼저 수정하여 해당 값을 참조하지 않도록 수정해야한다 
--1. 자식테이블에서 참조중인 값을 다른 값으로 변경(부모에 존재하는 것으로 변경해햐한다 )
--2. 자식테이블에서 참조중인 값을 NULL로 변경(정말 급한게 아니면 비추천)

--2. 참조중인 값을 NULL로 수정
UPDATE TBL_CASE 
SET PHONE_SERIAL_NUMBER = NULL
WHERE CASE_SERIAL_NUMBER = 'B';

UPDATE TBL_PHONE 
SET PHONE_SERIAL_NUMBER = 'S24-004'
WHERE PHONE_SERIAL_NUMBER = 'S24-002';

UPDATE TBL_CASE 
SET PHONE_SERIAL_NUMBER = 'S24-004'
WHERE CASE_SERIAL_NUMBER = 'B';

--1. 참조중인 값을 다른 값으로 변경 후 수정 
--자식의 FK를 변경시에는 부모에 존재하는 값으로 변경해야한다
UPDATE TBL_CASE 
SET PHONE_SERIAL_NUMBER = 'S24-005'
WHERE CASE_SERIAL_NUMBER = 'A';

UPDATE TBL_PHONE 
SET PHONE_SERIAL_NUMBER = 'S24-005'
WHERE PHONE_SERIAL_NUMBER = 'S24-001';

UPDATE TBL_CASE
SET PHONE_SERIAL_NUMBER = 'S24-005'
WHERE CASE_SERIAL_NUMBER = 'A';

--만약 부모에 없는 값으로 변경하려면 부모에 먼저 INSERT 하고 자식 FK를 수정한다 
INSERT INTO TBL_PHONE
VALUES('S24-006','BLUE',2,80,SYSDATE,10);

UPDATE TBL_CASE
SET PHONE_SERIAL_NUMBER = 'S24-006'
WHERE CASE_SERIAL_NUMBER = 'B';

--부모 테이블에서 데이터 삭제하기 
DELETE FROM TBL_PHONE 
WHERE PHONE_SERIAL_NUMBER = 'S24-006';--자식 테이블에서 참조중인 값이라서 삭제가 불가능

--부모 테이블의 데이터를 삭제하려면 자식 테이블의 참조중인 값들을 먼저 처리해야한다 
--1. 삭제한다 
--2. 수정한다 

--1.
DELETE FROM TBL_CASE 
WHERE PHONE_SERIAL_NUMBER = 'S24-006';

-- 부모테이블에서 삭제
DELETE FROM TBL_PHONE 
WHERE PHONE_SERIAL_NUMBER = 'S24-006';

--S24-001을 삭제하기
UPDATE TBL_CASE
SET PHONE_SERIAL_NUMBER = NULL
WHERE PHONE_SERIAL_NUMBER = 'S24-001';

-- 부모테이블에서 삭제
DELETE TBL_PHONE
WHERE PHONE_SERIAL_NUMBER = 'S24-001';